# 교착상태

# 교착상태의 개요

## 1. 교착상태의 정의

### 교착 상태(dead lock)

- 2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태

### 아사현상과의 차이

- 아사현상은 운영체제가 잘못된 정책을 사용하여 특정 프로세스의 작업이 지연되는 문제인 반면,
- 교착 상태는 여러 프로세스가 작업을 진행하다보니 자연적으로 발생하는 문제
- 따라서 교착상태가 발생하면 운영체제가 강압적으로 해결해야 함



## 2. 교착상태의 발생

- 시스템 자원, 공유변수, 응용 프로그램 등 사용시 발생할 수 있음

### 시스템 자원

- 다른 프로세스와 공유할 수 없는 자원을 사용할 때 발생

### 공유 변수

- 

### 응용 프로그램

- 데이터베이스가 데이터의 일관성을 유지하기 위해 잠금을 사용하는 과정에서 교착상태가 발생할 수 있음



## 3. 자원할당 그래프

### 자원할당 그래프(resource allocation graph)

- 프로세스가 어떤 자원을 사용 중이고 어떤 자원을 기다리고 있는지를 방향성이 있는 그래프로 표현한 것
- 프로세스는 원으로, 자원은 사각형으로 표현
- 프로세스가 자원을 사용중인 경우: 자원에서 프로세스로 향하는 실선의 화살표로 표시
- 프로세스가 자원을 기다리는 경우: 프로레스에서 자원으로 향하는 점선의 화살표로 표시
- 다중 자원(multiple resource)
  - 자원이 2개 이상의 프로세스를 동시에 허용하는 경우
  - 자원을 나타내는 사각형 내에 허용하는 프로세스의 수만큼 작은 동그라미로 표현

# 교착 상태 필요조건

## 1. 교착 상태 필요조건

- 상호배제, 비선점, 점유와 대기, 원형대기 4가지 조건을 모두 충족해야 발생

### 상호 배제(mutual exclusion)

- 한 프로세스가 사용하는 자원은 다른 프로세스와 **공유할 수 없는** 배타적인 자원이어야 한다는 것

### 비선점(non-preemption)

- 한 프로세스가 사용 중인 자원은 **중간에** 다른 프로세스가 **빼앗을 수 없는** 비선점 자원이어야 한다는 것

### 점유와 대기(hold and wait)

- 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태여야 함

### 원형 대기(circular wait)

- 점유와 대기를 하는 프로세스 간의 관계가 원을 이루어야 함



## 2. 식사하는 철학자 문제와 교착 상태 필요조건

- 교착상태 필요조건을 식사하는 철학자 문제에 적용

### 상호 배제

- 포크는 한 사람이 사용하면 다른 사람이 사용할 수 없는 배타적 자원임

### 비선점

- 사용중인 포크는 도중에 빼앗을 수 없음

### 점유와 대기

- 한 철학자가 왼쪽 포크와 오른쪽 포크를 모두 점유하거나, 두 포크를 모두 기다리는 상태라면 교착상태 X
- 하나의 자원을 점유한 상태에서 다른 자원을 기다리면 서로가 서로의 진행을 방해하는 상태이므로 교착상태 발생

### 원형 대기

- 원을 이룬다는 것은 선후관계를 결정할 수 없어 문제가 계속 맴돈다는 의미
- 만약 철학자들이 원형 식탁이 아닌 사각형의 식탁에서 한 줄로 식사를 하면, 한쪽 끝에서부터 식사를 시작하고 다 사용한 포크를 내려놓으면 교착상태가 발생하지 않음

# 교착 상태 해결 방법

## 1. 교착 상태 해결 방법

- 교착상태의 해결방법: 예방, 회피, 검출 + 회복

  | 해결 방법 | 특징                                           |
  | --------- | ---------------------------------------------- |
  | 예방      | 교착 상태를 유발하는 필요조건들을 무력화       |
  | 회피      | 교착 상태가 발생하지 않을 수준으로 자원을 할당 |
  | 검출      | 자원할당 그래프를 사용하여 교착 상태를 발견    |
  | 회복      | 교착 상태를 검출한 후 해결                     |

  

## 2. 교착 상태 예방

### 정의

- 교착 상태는 필요조건 4가지 중 하나라도 충족되면 발생하지 않기 때문에, 네 가지 조건 중 하나라도 발생하지 않도록 막는 방법

### 상호 배제 예방

- 시스템 내에 있는 상호배타적인 모든 자원을 없애버리는 방법
- 즉 시스템 내에 공유할 수 있는 자원만 남기는 것
- 그러나 현실적으로 어려운 방법이라 잘 사용되지 않음

### 비선점 예방

- 모든 자원을 도중에 빼앗을 수 있게 하는 방법
- 하지만 이 방법 역시 여러 문제로 인해 사용되지 않음
  - 빼앗을 수 있는 기준, 빼앗은 시간 중 얼마나 사용하도록 할지 등등
- 또한 아사현상을 일으킬 수 있고, 아사현상의 발생을 에이징으로 해결한다고 하더라도, 그렇게 되면 에이징을 통해 높은 우선순위를 가진 프로세스가 점유한 자원은 비선점 자원이 되어 다시 교착상태에 빠질 수 있음

### 점유와 대기 예방

- 자원을 전부 할당하거나 아니면 아예 할당받지 못하게 하여(all or nothing) 프로세스가 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방법
- 철학자 문제를 예로 들면 한 철학자가 식사를 시작할 때 양손에 포크를 잡지 못했다면 한손에 든 포크는 반납해야 함
- 그렇다면 동작이 빠른 철학자가 먼저 식사할 수 있게 됨
- 이 방법은 아예 제약을 풀어버리는 앞선 두 방법과 달리 프로세스의 자원 사용 방식을 변화시켜서 교착상태를 처리한다는 점에서 의미가 있음
- 단점
  - 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어려움. 어떤 상태에서 필요한 자원을 모두 확보후 실행했는데 추가로 필요한 자원이 생긴다면? 다시 확보하기 어렵게 됨
  - 자원의 활용성이 떨어짐. 필요한 모든 자원을 할당받게 되므로, 당장 사용하지 않을 자원도 미리 선점하게 되어 낭비가 심해짐
  - 많은 자원을 사용하는 프로세스가 그렇지 않은 프로세스보다 불리함
  - 결국 일괄 작업 방식으로 동작함

### 원형 대기 예방

- 점유와 대기를 하는 프로세스들이 원형을 이루지 못하도록 하는 방법
- 자원을 한 방향으로만 사용하도록 설정함으로써 예방 가능
- 자원에 숫자를 부여하고, 숫자가 큰 방향으로만 자원을 할당하는 것
- 이렇게 되면 숫자가 큰 자원을 할당받고 숫자가 작은 자원을 기다리는 프로세스는, 작은 수의 자원을 할당받을 수 없으므로 강제종료 되어 교착상태가 발생하지 않음
- 단점
  - 프로세스 작업 진행에 유연성이 떨어짐
  - 자원의 번호를 매기는 기준이 모호

### 결론

- 사용하기 어려움



## 3. 교착 상태 회피

### 교착 상태 회피의 개념

- 프로세스에 자원을 어느 수준 이상으로 나누어주면 교착상태가 발생하는지를 파악하여 그 수준 이하로 자원을 나누어주는 방법
- 프로세스의 작업 방식을 제약하는 교착 상태 예방에 비해 좀 더 유연한 방법
- 자원의 총 수와 현재 할당된 자원의 수를 기준으로 시스템을 안정상태(safe state)와 불안정 상태(unsafe state)로 나누고, 시스템이 안정 상태를 유지하도록 자원을 할당
  - 안정상태: 각 프로세스의 기대 자원과 비교하여 가용 자원이 크거나 같은 경우가 한번 이상인 경우
- 이때 불안정 상태는 반드시 교착상태가 발생하는 상태라는 뜻은 아니고, 불안정 상태가 커질수록 교착 상태의 발생가능성이 높아지는 것

### 은행원 알고리즘

- banker's algorithm

- 최악의 경우를 기준으로 자원의 할당량을 정함

- 변수

  | 변수                  | 설명                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | 전체 자원(Total)      | 시스템 내 전체 자원의 수                                     |
  | 가용 자원(Available)  | 시스템 내 현재 사용할 수 있는 자원의 수<br />(전체자원 - 모든 프로세스의 할당 자원) |
  | 최대 자원(Max)        | 각 프로세스가 선언한 최대 자원의 수                          |
  | 할당 자원(Allocation) | 각 프로세스에 현재 할당된 자원의 수                          |
  | 기대 자원(Expect)     | 각 프로세스가 앞으로 사용할 자원의 수<br />(최대 자원 - 할당 자원) |

- 각 프로세스는 자신이 사용할 자원의 최대 수를 운영체제에 알려줌

- 그러면 프로세스는 아래와 같은 기준으로 자원을 할당

  - 각 프로세스의 기대 자원과 비교하여 가용 자원이 하나라도 크거나 같으면 자원을 할당함. 가용자원이 기대자원보다 크다는 것은 그 자원을 사용하여 작업을 끝낼 수 있는 프로세스가 있다는 의미이므로 안정상태
  - 가용 자원이 어떤 기대 자원보다 크지 않으면 할당하지 않음. 이때는 가용자원을 사용하여 작업을 마칠 수 있는 프로세스가 없는 경우이므로 불안정 상태

### 교착상태회피의 문제점

- 프로세스가 자신이 사용할 모든 자원을 미리 선언해야 함
  - 미리 선언하는 것도 어려운 일이고, 선언한 자원이 정확하지 않으면 교착상태 발생 가능
- 시스템의 전체 자원 수가 고정적이어야 함
  - 안정 상태 or 불안정 상태 파악을 위해서는 자원 수가 고정적이어야 함
  - 그러나 현실적으로 일시적인 고장이나 새로운 자원이 추가되는 일 빈번
- 자원이 낭비됨
  - 불안정 상태 == 교착상태가 아님에도 불안정 상태가 아닐 때까지만 자원을 할당하는 것은 낭비

## 4. 교착 상태 검출

### 개념

- 운영체제가 프로세스의 작업을 관찰하면서 교착 상태 발생 여부를 계속 주시하는 방식
- 발견된다면 회복 단계를 밟음
- 교착상태 해결 방법 중 가장 현실적
- 타임아웃을 이용하는 방법과 자원할당 그래프를 이용하는 방법이 있음

### 타임아웃을 이용한 교착 상태 검출

- 일정 시간 동안 작업이 진행되지 않은 프로세스를 교착 상태가 발생한 것으로 간주하는 방법
- 특별한 알고리즘을 요하지 않음
- 단점
  - 엉뚱한 프로세스가 강제 종료될 수 있음
  - 모든 시스템에 적용할 수는 없음
    - 하나의 운영체제에서 동작하는 프로세스를 확인하는데는 적용 가능
    - 분산데이터베이스의 경우 데이터가 여러 시스템에 나누어져있고 각 시스템이 네트워크를 통해 연결되어있음. 이러한 경우에는 다른 시스템에 있는 프로세스의 응답이 늦어지는 것이 교착상태 때문인지 네트워크 문제인지 알 수 없어 이 방법을 적용하는 데 문제가 있음
- 위 단점에도 불구 자원할당 그래프를 이용하는 방법에 비해 선호됨
- 가벼운 교착 상태 검출이라고도 부름
- 예시
  - '프로그램이 응답하지 않습니다'
  - 데이터베이스에서의 교착상태 처리 - 체크포인트, 롤백, 스냅숏
    - 시스템 복원에서 '특정 시점으로의 복원'

### 자원 할당 그래프를 이용한 교착 상태 검출

- 자원할당 그래프에서 사이클이 발생하면 교착 상태가 검출된 것으로 판단

- 그러나 이것은 단일 자원을 사용하는 경우에 해당하고, 다중 자원을 사용하는 경우에는 자원 할당 그래프에 사이클이 존재한다고 해서 교착 상태라고 판단할 수 없음

- 장점

  - 프로세스의 작업 방식을 제한하지 않으면서 교착 상태를 정확하게 파악할 수 있음

- 단점

  - 자원할당 그래프를 유지, 갱신하고 사이클을 검사하는 작업으로 인해 오버헤드 발생
  - 이 같은 단점을 보완하기 위한 방법으로는 자원이 할당될 때마다 사이클을 검사하는 것이 아닌 일정시간마다 하는 방법이 있음

  

## 5. 교착 상태 회복

- 교착상태가 검출된 경우 교착 상태를 해결하는 후속 작업을 의미
- 교착 상태를 유발한 프로세스를 강제 종료하는데, 강제 종료 방법에 크게 두가지가 있음
- 첫번째로 교착 상태를 일으킨 모든 프로세스를 동시에 종료
  - 종료된 프로세스들이 동시에 작업을 시작하면 다시 교착 상태를 일으킬 가능성이 있음
  - 따라서 다시 실행할 때는 순차적으로 실행해야하고, 이때 그 순서에 대한 기준이 필요
- 두번째로 교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료
  - 하나씩 종료시키면서 나머지 프로세스의 상태를 파악하는 방법
  - 기준
    - 우선순위가 낮은 프로세스 먼저 종료
    - 우선순위가 같다면 작업 시간이 짧은 프로세스 먼저 종료
    - 위 두 조건이 같다면 자원을 많이 사용하는 프로세스를 먼저 종료
- 회복단계에서는 프로세스를 종료하는 것 뿐만 아니라 강제 종료된 프로세스가 실행되기 전에 시스템을 복구해야 함
- 시스템 복구는 명령어 실행마다 체크포인트를 만들어 가장 최근의 검사 시점으로 돌아가는 방식
  - 이 방식은 작업량이 상당하여 시스템에 부하를 주기 떄문에 선택적으로 사용해야 함



# 다중 자원과 교착 상태 검출







---

- 점유와 대기 예방도 자원에 대한 제약 푸는거 아닌가..?
