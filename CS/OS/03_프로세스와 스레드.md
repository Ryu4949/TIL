# 프로세스와 스레드

[TOC]



# 프로세스의 개요

## 1. 프로세스의 개념

- 프로그램: 저장장치에 저장된 정적인 상태
- 프로그램의 실행: 해당 코드가 메모리에 올라와서 작업이 진행되는 것
- 프로세스: 실행을 위해 메모리에 올라온 동적인 상태
- 누군가 작성한 프로그램이 **실행**되면 프로세스가 됨



## 2. 요리사 모형에의 비유

### 주문서의 역할

- 주문순서
- 주문한 테이블
- 인원 수
- 주문한 요리
- 주문 사항 등이 기재되어 있음

### 일괄 작업 방식의 요리

- 일괄작업시스템: 한번에 하나의 작업만 처리하는 방식
- 요리사모형에서는 레스토랑에 테이블이 하나만 있는 경우를 생각하면 됨
- 손님의 식사가 끝나야 다음 손님을 받을 수 있기에 효율성이 떨어짐
- 먼저 주문한 순서대로 손님을 받기 때문에 큐(queue)구조라고 볼 수 있음

### 시분할 방식의 요리

- 테이블이 여러개 있다면 일괄 작업 방식은 비효율적
- 효율성을 위해 한 손님이 식사하는 동안 다른 손님의 요리를 해야함
- 즉 이러한 방식은 CPU가 1개인 컴퓨터에서 여러 프로세스를 동시에 실행하는 것과 같은 원리
- 프로세스도 시간을 쪼개어 적절하게 배분하여 동시에 실행하는 것 처럼 느껴짐

### 시분할 방식에서의 예상치 못한 상황 처리

- 특정 요리를 하려고 하는데 재료가 준비되지 않은 상태라면?
- 그 주문서를 어떤 '대기 목록'에 옮기고 다른 주문서를 가져와 요리를 할 것임
- 이때 대기목록에 간 주문서의 재료가 모두 준비되었다고 할 때 현재 진행중이던 요리를 바로 멈추는 것은 비효율적
- 진행 중이던 요리를 마친 후에 대기 목록의 주문서를 다시 시작하는 것이 좋음
- 그 외에도 손님의 요청으로 요리 순서를 미루는 경우에는 '보류 목록'으로 간다고 볼 수 있고, 손님의 사정으로 식사를 못하게 되는 경우 주문서는 폐기하게 됨
- 이처럼 시분할 방식의 요리는 여러 목록을 옮겨 가면서 진행되는데, 운영체제에서의 프로세스의 처리도 이와 유사함



## 3. 프로그램에서 프로세스로의 전환

### 프로세스

- 컴퓨터 시스템의 작업단위
- task

### 프로그램에서 프로세스로의 전환

- 운영체제가 프로그램을 메모리의 적당한 위치로 가져옴
- 프로세스 제어 블록 생성(Process Control Block, PCB)
  - 요리사 모형에서 주문서에 해당하는 작업 지시서
  - 프로세스를 처리하는 데 필요한 다양한 정보를 담고 있음
  - PCB가 없다면 프로세스로 전환되지 못함. 즉 프로세스가 되었다는 것은 운영체제로부터 PCB를 받았음을 의미

### PCB가 담고있는 정보

- 프로세스 구분자(Process IDentification, PID)
  - 메모리에 여러 개의 프로세스가 존재하기 때문에, 이를 구분하기 위해 필요
- 메모리 관련 정보
  - 프로세스의 메모리 위치 정보
  - 경계 레지스터, 한계 레지스터
- 각종 중간값
  - 작업을 진행하다가 나중에 이어서 진행할 때를 위해 필요
  - 프로그램 카운터, 각종 레지스터

#### 정리

- 하나의 프로세스가 실행되려면 PID, 메모리 정보, 각종 중간값의 정보가 필요
- 이러한 정보를 보관하는 데이터 구조가 PCB
- 프로세스가 되려면 프로그램이 메모리에 올라오는 동시에 PCB가 생성되어야 함
- 프로세스가 종료되면 메모리에서 삭제되고 PCB 또한 폐기
- 운영체제 영역에 생성됨
- 프로세스 = 프로그램 + PCB
- 프로그램 = 프로세스 - PCB



## 4. 프로세스의 상태(process status)

### 프로세스의 네 가지 상태

#### 생성상태

- create status
- 프로세스가 메모리에 올라와 실행 준비를 완료한 상태
- PCB가 생성됨

#### 준비 상태

- ready status
- 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
- PCB는 준비 큐(ready queue)에서 기다리며 CPU 스케줄러에 의해 관리됨
  - 준비 큐는 다수가 동시에 운영됨

- CPU 스케줄러는 dispatch(PID) 명령으로 다음 PCB를 선택하는 작업을 처리

#### 실행 상태

- running status, execute status
- 프로세스가 CPU를 얻어 실제 작업을 수행하는 상태
- CPU의 개수 만큼 실행상태에 들어갈 수 있음
- 자신의 작업이 끝날 때까지 준비 상태와 실행 상태를 왔다갔다 함
- 작업할 수 있는 시간은 자신에게 주어진 시간(타임 슬라이스)만큼
- 프로세스가 실행 상태에서 입출력을 요청하면 CPU는 입출력 관리자에게 입출력을 요청하고 block(PID)을 실행
- block(PID)은 입출력이 완료될 때까지 작업을 진행할 수 없으므로 해당 프로세스를 대기 상태로 옮기고, CPU 스케줄러는 새로운 프로세스를 실행 상태로 가져옴(dispatch)

#### 완료 상태

- terminate status
- 주어진 시간동안 작업을 완료하여 PCB가 사라진 상태
- 정상적인 종료는 `exit()`으로 처리
- 강제종료(abort): 오류나 다른 프로세스에 의해 비정상적으로 종료
  - 코어 덤프(core dump): 강제종료가 발생하면 디버깅을 위해 강제종료 직전의 메모리 상태를 저장장치로 옮김


#### CPU 스케줄러(CPU scheduler)

- 준비 상태의 여러 프로세스 중 다음에 실행할 프로세스 선정하는 역할



### 프로세스의 다섯가지 상태: 대기상태

- 기존 네 가지 상태에다가 운영체제의 효율성을 고려하여 한 가지 상태 추가
- 대기상태(blocking status, wait status)
  - 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태
  - 작업의 효율성을 위해 입출력을 요청한 프로세스를 실행상태에 두지 않고 대기상태로 옮기고, 옮겨지고 나면 CPU 스케줄러가 준비상태에 있는 프로세스 중 하나를 실행 상태로 옮김
  - 대기상태에서 입출력이 끝난 프로세스는 바로 실행 상태로 가는 것이 아니라 준비 상태로 돌아가 차례를 기다림
  - 입출력이 완료되면 인터럽트가 발생하고, 여러 프로세스 중 이 인터럽트로 깨어날 프로세스를 찾는데 이것이 wakeup(PID)
  - 프로세스가 결정되면 해당 PCB가 준비 상태로 이동



### 휴식 상태와 보류 상태

- 활성상태(active status): 생성, 준비, 실행, 대기, 완료

#### 휴식상태(pause status)

- 프로세스가 일시적으로 작업을 쉬는 상태
- 멈춘 것처럼 보이나 실행을 잠시 멈췄을 뿐인 상태
- 데이터가 메모리에 그대로 있고, PCB도 유지되므로 프로세스는 멈춘 지점에서부터 재시작(resume)할 수 있음

#### 보류상태(suspend status)

- 프로세스가 메모리에서 잠시 쫓겨난 상태로 일시정지상태라고도 함
- 보류상태가 되는 경우
  - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
  - 프로그램에 오류가 있어서 실행을 미루어야 할 때
  - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
  - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
  - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때
  - 이 외에도 많은 경우가 있으나 대부분 컴퓨터의 성능을 떨어드리거나 실행을 미루어도 큰 지장이 없는 프로세스
- 보류상태에 들어가면 메모리 밖으로 쫓겨나 스왑 영역(swap area)에 보관
- 대기 상태에서 옮겨지면 보류 대기상태(block suspend status)
- 준비 상태에서 옮겨지면 보류 준비상태(ready suspend status)
- 각 상태에서 '재시작'하면 원래의 활성상태로 돌아가고, 보류대기상태에서 입출력이 완료되면 활성상태가 아닌 '보류 준비 상태'로 옮겨감

# 프로세스 제어 블록과 문맥 교환

## 1. 프로세스 제어 블록

- 프로세스를 실행하는 데 필요한 정보를 보관하는 자료구조
- Task Control Block(TCB)라고도 함
- 모든 프로세스는 고유의 PCB를 가지며, 프로세스 생성시 만들어지고 실행이 완료되면 폐기됨

### 프로세스 제어 블록의 구성

#### 포인터

- 준비상태나 대기상태는 큐로 운영되는데, PCB를 연결하여 준비상태나 대기상태의 큐를 구현할 때 사용

#### 프로세스 상태

- 프로세스가 현재 어떤 상태에 있는지

#### 프로세스 구분자

- 운영체제 내에 있는 여러 프로세스를 구분하는 용도

#### 프로그램 카운터

- 다음에 실행될 명령어의 위치를 가리키는 카운터값 저장

#### 프로세스 우선순위

- 대기상태 큐는 하나가 아니라 우선순위 별로 따로 운영됨
- CPU 스케줄러는 준비 상태에 있는 프로세스 중 실행상태로 옮길 프로세스를 선택할 때 우선순위를 기준으로 삼음
- 우선순위가 높을수록 더 먼저, 더 자주 실행됨

#### 각종 레지스터 정보

- 자신이 사용하던 각종 레지스터들의 중간값 보관

#### 메모리 관리 정보

- 메모리 위치 정보: 프로세스가 메모리의 어디에 있는지 나타내는 정보
- 경계 레지스터값, 한계레지스터 값: 메모리 보호를 위해 사용
- 기타 등등

#### 할당된 자원 정보

- 프로세스를 실행시키기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보

#### 계정 정보

- 계정 번호, CPU 할당 시간, CPU 사용 시간 등등

#### 부모 프로세스 구분자와 자식 프로세스 구분자

- PPID: 부모 프로세스를 가리키는 구분자
- CPID: 자식 프로세스 구분자



### 포인터의 역할

- PCB의 맨 위에 위치
- 시스템 내에는 다양한 종류의 입출력장치가 있기 때문에 모이는 프로세스도 다양
- 그래서 어떤 종류의 인터럽트가 들어왔을 때 그에 맞는 프로세스를 쉽게 찾기 위해서 같은 입출력을 요구한 프로세스끼리 모아놓게 됨
  - 예를들어 하드디스크의 입출력을 기다리는 프로세스/ CD-ROM의 입출력을 기다리는 프로세스 / LAN의 입출력을 기다리는 프로세스 등등..



## 2. 문맥 교환

### 문맥 교환의 의미

- context switching
- CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업
- 이 과정에서 실행중이던 프로세스의 PCB에는 지금까지의 작업 내용을 저장하고, 실행 상태로 들어오는 프로세스의 PCB의 내용으로 CPU가 다시 세팅됨
- 이렇게 두 프로세스의 PCB를 교환하는 작업이 문맥 교환



### 문맥 교환의 절차

#### 절차

- 현재 프로세스 P1이 실행중, 프로세스 P2는 준비상태
- P1이 주어진 시간을 다 사용하여 타임아웃이 되면 P1의 PCB에 지금까지의 작업 결과가 저장되고, 준비상태로 이동
- 준비 상태에 있던 P2가 실행상태로 가면 CPU의 레지스터가 P2의 PCB 값으로 채워지고 작업 진행

#### 문맥 교환이 일어나는 경우

- 한 프로세스가 주어진 시간을 다 사용한 경우
- 인터럽트가 걸리는 경우

# 프로세스의 연산

## 1. 프로세스의 구조

## 2. 프로세스의 생성과 복사

## 3. 프로세스의 전환

## 4. 프로세스의 계층 구조



# 스레드

## 1. 스레드의 개념

## 2. 멀티스레드의 구조와 예

## 3. 멀티스레드의 장단점

## 4. 멀티스레드 모델



# 동적할당영역과 시스템 호출

## 1. 프로세스의 동적 할당 영역

## 2. exit()와 wait() 시스템 호출

### exit() 시스템 호출

- `main()` 함수의 맨 끝에 `exit()` 혹은 `return()`문을 통해 자식 프로세스가 끝났음을 부모 프로세스에 알려줌

- `exit()` 함수는 전달하는 인자를 확인하여 자식 프로세스가 어떤 상태로 종료되었는지를 알려줌

  - `exit(0)`: 정상 종료
  - `exit(-1)`: 비정상 종료

- `fork()` 코드의 예

  ```c
  #include <stdio.h>
  #include <unistd.h>
  
  int main()
  {	int pid;
  	pid=fork();
  	if (pid<0) { printf("Error");
                 exit(-1); }
  	else if(pid==0) { printf("Child");
                      exit(0);}
  	else { printf("Parent");
           exit(0); }
  }
  ```

  - `exit()`의 인자가 음수인 경우는 프로세스 생성에 실패하는 등 에러가 발생하는 경우
  - 위 코드의 경우 'Parent'와 'Child'가 출력되는 것은 분명하지만 어떤 것이 먼저 출력될지는 알 수 없음
    - 두 프로세스는 독립적으로 움직이기 때문
    - 대부분 'Parent'가 먼저 출력되지만 가끔 'Child'가 먼저 출력됨

### wait() 시스템 호출

- 고아 프로세스
  - 위 코드의 경우 부모 프로세스에서 'Parent'를 출력하고 `exit()`함수를 통해 종료됨
  - 부모 프로세스의 경우 자식 프로세스의 자원을 정리해야 하는데, 이렇게 먼저 종료돼버리면 자식 프로세스의 `exit()` 함수는 돌아갈곳이 없어짐
  - 이런 경우를 고아 프로세스라고 함





---

- 아니 그래서 포인터가 뭔데..
