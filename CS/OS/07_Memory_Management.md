# 물리 메모리 관리

[TOC]



# 메모리 관리의 개요

- 이하의 메모리는 메인 메모리를 가리킴

## 1. 메모리 관리의 복잡성

- 메모리는 1B 크기로 나뉘며, 각 영역은 메모리 주소로 구분하며 보통 0번지부터 시작
- CPU는 메모리의 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터(MAR)를 사용
- 폰 노이만 구조의 컴퓨터에서 메모리는 유일한 작업 공간
- 과거의 일괄처리 방식과 달리 오늘날의 시분할 시스템에서는 운영체제를 포함한 모든 응용 프로그램이 메모리에 올라와 실행되기 때문에 메모리 관리가 복잡
- 메모리 관리는 운영체제를 비롯해 여러 작업을 동시에 처리할 때 메모리를 어떻게 관리하는가의 문제
- 복잡한 메모리 관리는 메모리 관리 시스템(Memory Management System, MMS)이 담당



## 2. 메모리 관리의 이중성

- 메모리 관리의 이중성

  - 프로세스의 입장에서는 메모리를 독차지하려고 하지만
  - 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고 싶어 하는 것
  - 즉 프로세스 입장에서 작업의 편리함과 관리자 입장에서 관리의 편리하이 충돌을 일으키는 것

  

## 3. 소스코드의 번역과 실행

### 컴파일러와 인터프린터의 동작

- 응용프로그램은 프로그래밍 언어로 만들고, 컴파일러를 사용하여 작성한 프로그램을 실행 가능한 코드로 변경
- 저급 언어(low level language): 기계어, 어셈블리어. 컴퓨터의 동작을 가장 직접적으로 표현한 언어
- 고급 언어(high level language): C언어, 자바 등. 사용자가 이해하기 쉽게 프로그래밍할 수 있는 언어
- 컴파일러(compiler): 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역 후 한번에 실행. C언어, 자바
- 인터프리터(interpreter): 소스코드를 한 행씩 번역하여 실행. 자바스크립트, 베이직 등



### 컴파일러의 목적

#### 오류 발견

- 소스코드에서 오류를 발견하여 실행시 문제가 없도록 하는 것
- 오류를 찾기 위해 심벌 테이블(symbol table)을 사용
  - 변수 선언부에 명시한 각 변수의 이름과 종류(type)를 모아놓은 테이블
  - 선언하지 않은 변수를 사용하지는 않았는지, 변수에 다른 종류의 데이터를 저장하지는 않았는지 알 수 있음

#### 코드 최적화

- 실행하기 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 작고 빠른 실행 파일을 만듦



### 컴파일러와 인터프리터의 차이

- 컴파일러를 사용하는 프로그래밍 언어
  - 사용할 변수를 먼저 선언한 후 코드를 작성
  - 실행 전에 소스코드를 점검하여 오류를 수정하고 최적화
  - 크고 복잡한 프로그램에 사용
- 인터프리터
  - 한 줄씩 위에서부터 실행되기 때문에 컴파일러가 하는 것 같은 확인작업을 할 수 없음
  - 간단한 프로그램에 사용



### 컴파일 과정

- 컴파일: 사용자가 작성한 소스코드를 목적 코드(object code)로 변환한 후 라이브러리를 연결하고 최종 실행 파일을 만들어 실행하는 과정

- 과정

  - 소스코드 작성 및 컴파일

    - 이 과정에서 목적 코드를 얻음

  - 목적 코드와 라이브러리 연결

  - 동적 라이브러리를 포함하여 최종 실행

    

## 4. 메모리 관리자의 역할

- 메모리 관리
- 메모리 관리자는 정확하게는 메모리 관리 유닛(Memory Manage Unit, MMU)이라는 하드웨어
- 작업
  - 가져오기(fetch)
    - 프로세스와 데이터를 메모리로 가져오는 작업
    - 사용자가 요청하면 가져오고, 때로는 사용자의 요청이 없더라도 필요할 것이라고 예상되는 데이터를 가져오기도 함(prefetch)
  - 배치(placement)
    - 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정
    - 그 전에 메모리를 어떤 크기로 자를지가 중요
  - 재배치(replacement)
    - 꽉 찬 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보내는 작업
- 정책
  - 가져오기 정책
    - 프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정하는 정책
  - 배치 정책
    - 가져온 프로세스를 메모리의 어떤 위치에 올릴지 결정하는 정책
    - 메모리를 같은 크기로 자르는 것을 페이징(paging)이라고 하고, 프로세스의 크기에 맞게 자르는 것을 세그먼테이션(segmentation)이라고 함
  - 재배치 정책
    - 메모리가 꽉 찬 경우 어떤 프로세스를 내보낼 지 결정하는 정책
    - 이 때 자주사용할 프로세스를 내보내면 성능이 떨어지고, 사용하지 않을 프로세스를 내보내면 시스템 성능이 향상되므로, 사용하지 않을 프로세스를 찾아서 내보내는 알고리즘이 필요
      - 이것을 교체 알고리즘(replacement algorithm)이라고 함

# 메모리 주소

## 1. 32bit CPU와 64bit CPU의 차이

- CPU의 비트는 한 번에 다룰 수 있는 데이터의 최대 크기를 의미
- CPU의 내부 부품은 이 비트를 기준으로 제작
- CPU 비트는 메모리 주소 공간(address space)의 크기와도 연관이 있음
  - 32bit CPU의 경우 MAR의 크기가 32bit, 따라서 표현할 수 있는 메모리 주소 범위가 총 2^32개로 총크기는 약 4GB
  - 반면 64bit CPU의 경우 거의 무한대에 가까운 메모리를 사용 가능
- 물리 주소 공간(physical address space): 하드웨어 입장에서 바라본 설치된 메모리의 주소 공간.
- 논리 주소 공간(logical address space): 사용자 입장에서 바라 본 주소 공간

## 2. 절대 주소와 상대 주소

### 메모리 영역의 구분

- 운영체제 영역과 사용자 영역
- 사용자 프로세스는 운영체제 영역을 피하여 메모리에 적재 됨
  - 예를 들어 0~999번지 중에서 운영체제 영역을 399번지까지 사용한다면 사용자 영역은 400번지부터 시작
  - 그런데 만약 운영체제 영역이 바뀌면 그 때마다 매번 사용자 프로세스가 적재되는 주소가 달라지기 때문에 이를 피하기 위해 사용자 프로세스를 메모리의 최상위, 즉 현재 예시의 경우 999번지부터 사용하는 방법이 있음

### 절대 주소와 상대 주소

- 절대 주소와 상대 주소

  | 구분      | 절대 주소                | 상대 주소                               |
  | --------- | ------------------------ | --------------------------------------- |
  | 관점      | 메모리 관리자 입장       | 사용자 프로세스 입장                    |
  | 주소 시작 | 물리 주소 0번지부터 시작 | 물리주소와 관계없이 항상 0번지부터 시작 |
  | 주소 공간 | 물리 주소(실제 주소)공간 | 논리 주소 공간                          |

### 상대 주소를 절대 주소로 변환하는 과정

- 절대주소를 사용하면 별다른 변환과정 없이 메모리 접근 가능
- 상대주소를 사용하면 상대주소를 실제 메모리 내의 물리주소(절대 주소)로 변환해야 함
- 과정
  - 사용자 프로세스가 특정 상대주소에 있는 데이터를 요청
  - CPU는 메모리 관리자에게 그 상대주소에 있는 데이터를 가져올 것을 명령
  - 메모리 관리자는 재배치 레지스터를 사용하여 상대주소를 절대주소로 변환하고 그 절대주소에 저장된 데이터를 가져옴
    - 재배치 레지스터: 주소 변환의 기본이되는 주소값을 가진 레지스터



# 단일 프로그래밍 환경에서의 메모리 할당

## 1. 메모리 오버레이(memory overlay)

- 현재는 별로 문제되지 않지만, 과거에는 작은 메모리로 큰 프로그램을 어떻게 작동시킬 것인지가 문제였음

- 프로그램의 크기가 실제 메모리(물리 메모리)보다 클 떄 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법

- 하나의 메모리에 프로그램을 겹겹이 쌓아놓고 실행하는 것

- 프로그램을 몇 개의 모듈로 나누고 필요할 때마다 모듈을 메모리에 가져와서 사용

- 프로그램 전체를 메모리에 올려놓고 실행하는 것보다는 속도가 느리지만 메모리가 프로그램보다 작을 때도 실행할 수 있다는 점에서 유용

- 어떤 모듈을 가져오거나 내보낼지는 CPU 레지스터 중 하나인 프로그램 카운터(PC)가 결정

- 메모리 오버레이의 의미

  - 한정된 메모리에서 메모리보다 큰 프로그램의 실행이 가능
  - 가상 메모리 시스템의 기본이 되는 개념
  - 프로그램 전체가 아니라 일부만 메모리에 올라와도 실행이 가능
  - 메모리를 여러 조각으로 나누어 여러 프로세스에 할당할 수 있다는 의미이기도 함

  

## 2. 스왑

- 다른 프로그램을 메모리에 올리기 위해 기존에 메모리에 올라와있던 프로그램을 다른 곳에 보관하는 것
- 저장장치는 장소만 빌려주고 관리는 메모리 관리자가 함
- 사용자가 인식하는 메모리 크기 = 실제 메모리 크기 + 스왑 영역의 크기

### 스왑 영역

-  swap area
- 메모리가 모자라서 쫓겨난 프로세스를 모아두는 저장장치 내의 특별한 공간

### 스왑인

- swap in
- 스왑 영역에서 메모리로 데이터를 가져오는 작업

### 스왑 아웃

- swap out
- 메모리에서 스왑 영역으로 데이터를 내보내는 작업

# 다중 프로그래밍 환경에서의 메모리 할당

## 1. 메모리 분할 방식

## 2. 가변 분할 방식의 메모리 관리

## 3. 고정 분할 방식의 메모리 관리

## 4. 버디 시스템



# 컴파일과 메모리 관리

## 1. 컴파일 과정

## 2. 변수와 메모리 할당

