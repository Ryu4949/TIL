# 알고리즘

- 문제를 해결하기 위한 절차나 방법
- 좋은 알고리즘을 위한 조건: 정확성, 작업량, 메모리 사용량, 단순성, 최적성
  - 단순성: 단순한 코드가 더 어려운 코드일 때도 있음

- 알고리즘 성능의 측정
  - 시간 복잡도(Time Complexity)
    - 시간복잡도 함수에서 가장 큰 영향을 주는 최고차항만 표시
    - 1 > logn > n > nlogn > n^2 > 2^n > n!



## 배열

- 배열의 필요성
  - 하나의 선언으로 둘 이상의 변수를 선언할 수 있다.
  - 다수의 변수로 하기 힘든 작업을 쉽게 할 수 있다.



## 정렬

- 버블/카운팅/선택/퀵/삽입/병합



### 버블 정렬

- 선택 정렬과 헷갈리지 말것
- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

- 시간복잡도: O(n^2)

- 배열을 활용한 버블 정렬

  ```python
  def BubbleSort(a, N):
      for i in range(N-1, 0, -1):
          for j in range(0, 1):
              if a[j] > a[j+1]:
                  a[j], a[j+1] = a[j+1], a[j]
      return
  ```

  

### 카운팅 정렬

- 정수나 정수로 표현 가능한 자료형만 가능
- 1단계: data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열에 저장
- 일단은 개수를 세는 방법, 그리고 누적합을 시켜주는 방법을 먼저 생각해보자.

- 시간복잡도: O(n+k)
  - 시간복잡도에 k가 있는 이유는, 때때로 k가 n보다 클 수가 있음. n에 비해 작다면 무시해도 되지만 그렇지 않으면 무시할 수 없다.



### Baby-gin Game

- 



---

## 알고리즘 왜 공부?

- 코테를 붙어야 함
- A, A+ 정도 level이 되면 NKLCB 문제를 받았을 때 '아 이 문제는 어떻게 접근하면 되겠구나!' 하는 수준이 됨(풀 수 있는 거랑은 별개로)



## 알고리즘 주간의 GroundRule

1. 조를 맺어서 활동하는데 항상 '반응'을 해줄 것
2. 우리는 우리의 생각을 말이 아닌 코드로 보여주는 것. 각자의 코드에 정답은 없다. "대체 코드를 왜 저렇게 짜지?"라고 생각하면 안됨. 코드를 보이는 것을 부끄러워하지 말 것. 더 많이 표현하고 더 많이 배워가라.



---

# 완전 검색

- 속도는 느리지만, 답을 찾지 못할 확률이 작음



---



- n자리 수를 끝에서부터 한자리씩 분리할 때

  ```python
  num = 456789
  c = [0] * 12
  for i in range(6):
      c[num % 10] += 1
      num //= 10
  ```

  

- ```python
  import sys
  sys.stdin = open('input.txt')
  ```
