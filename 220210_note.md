- 시간 복잡도 vs 공간 복잡도
  - 시간 복잡도가 더 중요
  - 옛날에는 공간이라는 게 비쌌음. 옛날엔 아이X버 128mb 짜리도 엄청 비쌌음. 요즘엔 다들 몇 기가/테라 짜리 쓰시는지 ?

### 빅-오 표기법

- n이 엄청나게 커졌을 때를 가정함
- 가장 큰 영향력을 주는 n에 대한 항만을 표시하고 계수는 생략
- 빅-오 표기법은 알고리즘의 '최악의 경우'를 상정한 것
  - 최악의 경우에도 시간 복잡도가 O(1)이다~
- 어떻게 계산하죠?
  - for와 while만 보면 됨



### 얕은 복사와 깊은 복사

- 슬라이싱 형태를 해주면 깊은 복사가 됨

  ```python
  lst = [1, 2, 3, 4]
  a = [0:2]
  #a는 [1, 2]지만 원본 lst가 잘리지는 않음
  ```

- 하지만 슬라이싱을 통한 깊은 복사를 하고 싶다면 1차원 리스트만 가능. 2차원 이상은 ㄴㄴ

- 2차원 이상일 때는 그냥 무지성 deepcopy ㄱㄱ



### 2차원 리스트 초기화

```python
#1
zeros = [[0] * 5] * 5
: 얕은 복사의 향연
 
zeros[0][0] = 100 하면 내부 5개 리스트의 각 0번째 인덱스가 모두 100으로 바뀜
```



### 리스트 사이에 리스트 넣기

```python
lst = [1, 2, 3, 4]
lst[2:2] = ['a', 'b', 'c']
```



### 리스트 내용 변경하기

```python
lst = [1, 2, 3, 4]
lst[1:3] = ['a', 'b']
#길이가 달라도 가능
lst[1:3] = ['a', 'b', 'c', 'd', 'e']
```





## 정렬

- 버블 소트: 시간복잡도 n^2
- 카운팅 정렬: 시간복잡도가 n+k라서 매우 좋은 정렬방법. 하지만 제한사항이 좀 많음
  - 왜 굳이..??
  - 엄격한 정렬을 위해서!
  - 우리 눈에는 같아 보이는 1, 1, 1,1 이라도 엄격하게 정렬을 하려면 원래 앞에 있던 1이 앞에 있어야 함(stable sort)

- 참고로 파이썬 내부에 있는 sort()는 파이썬 2버전까지는 퀵정렬 버전이었고, 이후 버전에서는 조금 더 빠른 것으로 바뀌었다고 함



