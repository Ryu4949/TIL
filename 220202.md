## 변수

- 변수의 이름으로 내장함수나 모듈 등의 이름 사용 불가능하다는 게 아예 에러가 발생하지는 않는다는거? 그냥 그렇게 했을 때, 같은 이름의 내장함수를 사용할 경우에 꼬여서 사용하지 말라는 뜻?

- 예약어는 변수 이름 쓰는 것 자체로 에러 발생

- 내장함수는 불가능하지는 않은데, 동명의 함수를 사용할 경우에 꼬임

  ```python
  sum = 1
  a = 2
  print(sum) #1
  print(sum(a, sum)) #TypeError: 'int' object is not callable
  ```

- 패킹/언패킹





## 자료형

### 점검사항

- sequence?
- iterable?
- mutable?

- (hashable?)
- 요소값에 접근가능?



### 셋(Set)

- 셋(set)은 mutable한 자료형이지만 immutable한 객체만 담을 수 있다. 정확하게는 unhashable한 자료형만 담을 수 있다. 따라서 immutable한 자료형이지만 unhashable한 자료형을 요소로 포함하고 있는 `(1, 2, [1, 2])`와 같은 것은 담을 수 없다.

- set은 중복된 값을 쉽게 제거해주는 기능을 하지만, 이후 순서가 무시되므로 순서가 중요한 경우에는 사용하기 어렵다. 그러나 셋의 요소 중 숫자의 경우에는 항상 크기가 작은 순으로 정렬된다.
  - 숫자만 있는 경우: 작은 순으로 정렬되고 중복된 값이 제거된다.
  - 문자만 있는 경우: 출력할 때마다 셋에 담겨있는 위치가 달라진다.
  - 숫자+문자인 경우: 숫자와 문자의 위치가 매번 다르고, 서로 섞여있을 수 있으나 그 와중에 숫자는 작은 순으로 정렬되어 있다.
- `.add()`: set에 한 개의 값만 추가할 경우
- `.update()`: set에 여러 개의 값을 한 번에 추가할 경우 ex) set1.update([1,2,3])
  - `.remove()`: 값을 제거할 때. `del`은 안됨
    - `discard()`와의 차이점은?
      - `remove()`의 경우 제거하려는 대상이 존재하지 않는다면 에러가 발생하지만 `discard()`의 경우에는 에러가 발생하지는 않는다.

### 문자열

- 추가적인 이스케이프 코드

  ```python
  #1.
  \f: 글자의 위치가 유지되면서 줄이 바뀜
  print('abx\fde')
  ---------------------------- 
  abx
     de
  
  #2.
  \b: 백스페이스. 바로 앞 글자를 지움
  print('abx\bde')
  ----------------------------
  abde
  
  #3.
  \a: 출력할 때 무슨 소리남
  ```

- 문자열 포맷팅에서 숫자를 넣고 싶을 때 꼭 `%d`를 써야 하는 것은 아니다. `%s`를 쓰고 숫자를 입력해도 그대로 입력되고, `a = 1, b = 2`일 때 `%s` 뒤에 `%(a+b)`를 입력해도 곧잘 출력된다. 다만 `%d`에 실수를 입력한다거나 할 때는 주의가 필요.

- **포맷코드+숫자 활용**

  - `%(-)숫자s`: -가 있으면 문자열을 왼쪽 정렬, 없으면 오른쪽 정렬, 총길이는 숫자만큼. 포맷코드는 s 말고 다른 것도 가능

    - 예를 들어 `''%-10s안녕'%'하이'`이면, `하이        안녕`이 출력되고, '하이'와 '안녕' 사이의 공백은 8칸이다.

  - `%0.숫자f`: 소수점을 (숫자)번째까지 나타내고 싶을 때 사용 가능하다. 소수점 앞에는 위에서와 같이 전체길이와 정렬을 설정할 수 있다. 이 때 소수점도 전체 길이에 포함된다.

  - `{:<숫자}`: <는 왼쪽 정렬, >는 우측 정렬, ^는 가운데 정렬. 숫자는 전체 길이

  - `{:<10.4f}`: <. >, ^를 통해 정렬위치, 소수점 앞의 숫자는 전체 길이, 소수점 뒤의 숫자는 표시할 소수점이하 자릿수

  - f-포맷팅에서도 같은 기호를 사용하여 정렬, 전체 길이를 설정할 수 있다.

    ```python
    y = 3.141592
    print(f'{y:>10.4f}')
    #    3.1416
    #f가 있으면 4번째 자리까지 표현하는데, 이 때 5번째 자리에서 반올림
    
    print(f'{y:>10.4}')
    #     3.142
    #f가 없으면 4번째 자리에서 반올림
    ```

  - f-포맷팅에서는 정렬기호 앞에 공백을 채울 문자를 설정할 수 있다.



### 리스트

- `remove()`
- `insert()`
- `del()`
- `pop(x)`: x자리에 값을 넣지 않으면 리스트의 맨 오른쪽 값을 반환 후 제거, 값을 넣으면 해당 인덱스의 값을 반환 후 제거



### 딕셔너리

- `del[key]`
- `a.keys()`의 type은 `dict_keys(<class 'dict_keys'>)`
- `.get(key)`: a라는 딕셔너리가 있을 때, `a.get(key)`와 `a[key]`는 동일한 결과값을 돌려준다. 하지만 찾고자하는 `key`가 없을 때 `get`은 `None`을 돌려주고, `a[key]`는 에러를 발생시킨다는 차이가 있다.
  - `.get()`을 쓸 때 찾는 `key`가 없을 때,  `.get(key, '하이')`와 같이 그런 상황에서 돌려줄 기본값을 설정할 수 있다.

### 불

- `bool(None)`: `False`





## 함수

- 키워드 파라미터 `kwargs`
  - 키워드 파라미터 입력하면 딕셔너리가 생성하는데 key를 숫자로 할 수는 없나??
- `return`: 함수의 반환 값은 오로지 `return`에 의해서만 생성됨. 어떤 값을 반환하고 싶을 때뿐만 아니라 특정 조건에서 함수를 빠져나가고 싶을 때도 `return`을 쓰면 된다.

- `def print_name(name, *args):` : 정상 작동

- `def print_name(*args, name):` 오류

- 패킹할 때 `*x, y = 1, 2, 3, 4`일 때 `x = [1, 2, 3]`으로 리스트

  - ```python
    def print_name(*args):
        print(args)
    print_name('일남', '이석', '삼식')
    # ('일남', '이석', '삼식')으로 tuple
    ```

- `nonlocal`

