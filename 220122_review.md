- 딕셔너리의 키에는 중복된 값은 올 수 없다

  - 여기서 말하는 중복된 값은 그냥 외형이 같은 값을 말하는가 아니면 고유주소(id)가 같은 값을 말하는가?

    ```python
    #1번
    a = [1, 2]
    b = [1, 2]
    print(id(a))
    print(id(b))
    -----------------
    140285878362880
    140285878362240
    
    #2번
    a = (1, 2)
    b = (1, 2)
    print(id(a))
    print(id(b))
    -----------------
    140674445035456
    140674445035456
    ```

    처음에 생각없이 key로 리스트를 넣어봐야겠다!고 해서 a와 b 각각에 같은 리스트를 넣고 id를 출력해보니 다른 값이 나온다. 그 후에 리스트는 key가 될 수 없다는 걸 다시 생각하고 a와 b 각각에 같은 튜플을 넣었더니 고유주소 값이 같게 나옴

    - 시간날 때 조금 더 고민해보자~

  - 중복된 값이 들어가는 경우 에러가 나지는 않는다. 간단한 실험에 따르면 중복된 키가 있을 경우, 중복된 키 중 가장 뒤에 입력된 (키, 값)이 반환됨

- 특정한 형식으로 숫자 출력하는 법 복습!!

  - ex) 지역번호 02를 표현하는 법. 물론 str으로 할 수 있겠지만

- 실수를 int형으로 변환할 경우 소수점은 버린다(반올림 아님)

- list도 str으로 바꿀 수 있다. 리스트 그 모양 그대로 문자열이 된다.

- 어떤 자료형이든 `range`로 바꾸는 것은 안된다.

- `print(not 0)` ===> `True`

- -5부터 256까지의 id는 동일하다는 말이 .. ??

- 시퀀스형 연산자간 연산: 튜플도 됨. range는 안됨

- ```python
  -3 ** 6  ====> -729
  (-3) ** 6 ===> 729
  ```

- dictionary comprehension

  ```python
  #key, value에 동일한 변수 사용할 때
  cubic = {x:x**3 for x in range(1,4)}
  
  #key, value에 다른 변수 사용할 때
  cubic = {x:y for x in range(1,4) for y in range(5,8)}
  #단 이렇게 하면 (1, 5) (1, 6) (1, 7) (2, 5) (2, 6)... 가 되어
  #key값에 중복이 발생하므로 최종적으로는
  {1: 7, 2: 7, 3: 7}
  #만 남는다
  ```

