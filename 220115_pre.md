- **람다식**
- 중첩함수



---

# 44차시 - 내장 함수

### 수치 연산 함수

1. abs()
2. divmod(): 인자1을 인자2로 나눴을 때의 몫과 나머지를 튜플 객체로 변환

3. pow(): 인자1의 값을 인자2의 값으로 제곱한 결과를 반환



### 시퀀스형/반복 가능한 자료들을 다루는 함수

1. all(): 모든 항목이 true이면 true, 하나라도 false이면 false
   - 공백문자열, 숫자 0, False, None은 False
2. any(): 하나라도 True이면 True
3. **enumerate()**: List, Tuple, 문자열과 같은 시퀀스형을 입력받아 인덱스를 포함하는 튜플 객체를 항목으로 구성하는 enumerate 객체를 반환하는 함수
4. **filter()**: 조건에 해당하는 항목을 걸러내는 함수
5. list(), tuple(), set(), dict()
6. map(): 인자2로 반복 가능한 자료형을 전달받고, 자료형의 각 항목에 대해 인자1의 함수를 적용한 결과를 맵 객체로 반환
7. max(), min()
8. range(시작 값, 종료 값, 증감치)
9. sorted(): 오름차순 리스트
10. list(reversed()) : 내림차순 리스트. 그냥 reversed()는 안됨
11. zip(): 둘이상 반복 가능한 자료형을 인자로 전달받아, 동일 위치의 항목을 묶어 튜플을 항목으로 구성하는 zip개체 생성. 단 인자로 전달된 객체는 동일 자료형이면서 항목의 개수가 같아야 함



### 변환 함수

1. chr(), ord(), hex()
2. int(), float(), str()
   - int(float)면  정수부분만 반환



### 객체 조사를 위한 함수

1. **dir()**
2. globals(), locals()
3. id(): 보통은 고유주소를 16진수로 봄
4. **isinstance(), issubclass()**



### 실행관련 함수

1. eval()



---

# 54차시 - 예외처리

### 오류의 종류

1. 구문오류: 해석단계
2. 예외: 실행단계



### 예외 처리 방법

1. if 문을 이용
   - 정상적인 흐름을 제어할 경우에만 사용
2. try ~ except 
   - 예외가 발생했을 때 처리

3. try ~ except ~ else
   - 예외 발생시 + 예외 미발생시 처리

4. try ~ except ~ else ~ finally
   - 예외 발생시 + 예외 미발생시 + 예외 발생여부와 무관하게 실행 



### 예외 객체

- 코드를 실행 중 오류가 발생하면 만들어진 것으로, 오류 발생과 관련한 정보를 가짐

- try / except `Exception as ex`
- 다중 except문을 사용하여 예외 객체에 따른 분기 가능
  - try / except ValueError as ve / except ZeroDivisionError as ze
  - 이 경우 ValueError 발생시 첫번째 except문을 실행, ZDE 발생시 두번째 except문 실행



### 강제로 예외를 발생시키는 방법

- raise: `raise ValueError("~")`



---

# 객체지향

- 대규모 프로그램 효율적 코딩 가능



### 객체지향의 이해

- 좀 더 효율적으로 프로그램을 만들기 위한 프로그래밍 기술
- 프로그래밍 로직을 상태와 행위로 이루어진 객체를 만든 다음, 해당 객체들을 레고처럼 조립하여 하나의 프로그램을 만드는 것
- 즉, 객체를 만들고 그 객체들을 이용해 문제를 해결하려는 프로그래밍 방법



### 객체란?

- 정의: 메모리에 로딩된 클래스를 통해 클레스를 템플릿으로 하여 메모리 상에 생성된 정보, 인스턴스 라고도 함
- 고유의 속성을 가지며 클래스에서 정의한 행위 수행

- 변수 + 메서드
- 변수에는 값, 메서드에는 실행코드가 저장되고 변수와 메서드가 서로 연관된 것들끼리 묶인 것이 객체



### 객체지향 프로그래밍

- 결국 객체지향이란 객체들을 부품으로 잘 조립해 만든 레고블럭과 비슷
- 이러한 부품은 여러 곳에서 재사용이 가능
- **부품화**, **재사용성**



### 클래스

- 정의: 같은 문제 도메인에 속하는 속성과 행위

- 이러한 부품 객체를 만들기 위한 청사진, 설계도, 템플릿
- 클래스는 추상화의 과정을 통해 만들어짐



### 메서드

- 정의: 클래스로부터 생성된 객체 사용 시 객체에 명령을 내리는 행위
  - 이를 '객체가 가지고 있는 메서드를 호출한다', '객체에 메시지를 전달한다'고도 함
- 한 객체의 속성을 조작할 목적으로 사용
- 객체 간의 통신은 메시지 전달을 통해 이루어짐



### 객체지향 프로그래밍의 특징

1. 추상화
   - 객체에서 공통된 속성과 행위를 추출하는 것
   - 공통의 속성과 행위를 찾아서 타입을 정의하는 과정
   - 즉 불필요한 정보는 숨기고 중요한 정보만 표현해 프로그램을 간단히 만드는 것
   - 이렇게 추상화를 통해 정의된 데이터 타입을 **추상 데이터 타입**이라고 함
     - 이는 데이터 타입의 표현과 연산을 캡슐화 한 것
     - 접근 제어를 통해 데이터의 정보를 은닉할 수 있음
2. 상속
   - 클래스의  속성과 행위를 하위 클래스에 물려주거나, 상위 클래스에서 물려받는 것으로 새로운 클래스가 기존 클래스의 데이터와 연산을 이용할 수 있게 하는 기능
   - 상속의 효과
     - 재사용으로 인해 코드가 줄어드는 이점이 있음(속성, 행위를 다시 정의할 필요가 없으므로)
     - 범용적인 사용이 가능하게 함
     - 자료와 메서드의 자유로운 사용 및 추가로 덧붙임으로써 새로운 형태의 클래스로 발전 가능
3. 다형성
   - 다양한 형태로 나타날 수 있는 특징으로, 어떤 한 요소에 여러 개념을 넣어놓는 것
     - 오버라이딩: 같은 이름의 메서드가 여러 클래스에서 다른 기능을 하는 것
     - 오버로딩: 같은 이름의 메서드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것
     - 메서드 오버라이딩: 상속으로 물려 받은 자료나 메서드를 그대로 사용하지 않고 하위 클래스에서 새로 정의해 사용하는 기법
       - 상위 클래스의 메서드와 동일한 서명(매개변수의 타입, 개수, 리턴 타입)을 가져야 함. 이를 통해 코드의 재사용성이 향상됨
     - 메서드 오버로딩: 클래스 내부에 동일한 이름의 행위를 여러 개 정의하는 것
       - 메서드 이름이 같고, 매개변수의 타입과 수는 서로 달라야 함
       - 리턴 타입은 관계하지 않음
       - 메서드 이름을 하나로 통일 가능하며, 같은 이름의 메서드에 여러 종류의 매개 변수를 받을 수 있음



# 클래스

- 객체 생성을 위한 청사진/템플릿



### 인스턴스 메서드

- self가 가리키는 객체의 필드 정보에 접근해 특정 목적의 기능을 수행하도록 정의된 메서드

### 인스턴스 변수

- 클래스 내에서 self.변수 형태를 가지는 변수로, 객체마다 가지고 있는 객체 고유의 정보 
- `self.__name = name`처럼 _(underbar) 2개를 붙여주면 getter, setter의 제공여부에 대한 고민 가능 

### 데코레이터 기능

- 변수 이름과 같은 메서드를 만들어 사용 가능
- @property 를 기술하거나, @property.setter 로 사용 가능

### 클래스 변수

- 클래스 내에서 클래스명.변수 형식으로 선언된 변수

### 클래스 상속

- 부모 클래스로부터 자식 클래스로 동작의 재사용, 확장, 수정. 단일 상속만 지원함

### 메서드 오버라이딩

- 부모 클래스에 있는 메서드와 동일한 서명을 가진 메서드를 자식 클래스에서 다시 정의해 사용하는 것

### 메서드 오버로딩

